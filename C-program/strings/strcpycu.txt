# 計算機程式設計　作業四 #

 - 課程：呂學展 計算機程式設計
 - 繳交期限：104/6/5 23:55
 - 作者：王鼎鈞 <c34031328@mail.ncku.edu.tw>

這是一個操作字串的練習。
我有用 `#include <string.h>` 標頭檔。
（我周日寫的，周一上課時才發現老師沒有教 
string.h ，應該沒關係吧？
上課作業中我有幾題用到 string.h ，
忘了有沒有過……。）

unix 在這點比 windows 方便很多。
幾乎每個安裝的程式在安裝時都會附上 
[[man_page|使用手冊]] ，
包括函式庫和有寫好介面的程式。
所以只要 `man strlen` 就可以查到詳細的使用說明。
像字串的函數我常常要查：會不會把結尾的 `\0` 吃進來、
如果長度不夠會不會溢位等有的沒的。

windows 就只能 google 。
很難想像 windows 使用者在沒有 man page 
也沒有 google 的時代是怎麼活過來的。


## 程式設計 ##

宣告一堆子函數，大致來說是一題一個子函數。
但某些分開寫很麻煩，所以寫在一起。


### static: 靜態變數 ###

寫到這題我才發現我靜態變數沒學好。
我想回傳陣列，這可以接受。
但我寫的是 C 語言， C 語言很鳥。
所以我得要宣告 **靜態變數** 然後傳址，或 **全域變數** 。
好，所以我宣告： `static char s[n]` ，不給。
靜態陣列的長度不能宣告成變數……，必須是指定值。

於是我只好確定了字串的大小，然後寫死在原始碼裡。
二字串加上字串結尾 20+1+20+1 ，共 42 。
google 了一下，在維基百科查到的 [[C語言#C99|C99 標準]] ，
 *才* 開始支援陣列的大小為動態指派；但 static 和全域依然不淮。
[[C語言#.E5.86.85.E5.AD.98.E7.AE.A1.E7.90.86|這裡有詳細的原因。]]
 ""同時也是這一版才開始支援 `for (int i=0; i<7 ; i++ )` ：
   也就是在 for 開頭才宣告 i 的寫法。
   但我在 DevC++ 會 compile error 是怎樣？"" 


### 指標與陣列 ###

所以我為什麼要回傳陣列呢？因為我想要回傳一個字串。
那標準的 C 作法呢？我後來想想，認為是直接修改傳入的字串。
 `strcat()` 、 `strcpy()` 都是這麼幹的。
但我一開始不會修改傳入的字串。
我忘了可以 *接收一個陣列* ，我都是用指標接收。
*而指標指向的字串是不能修改的。*
所以整份作業我都在操作指標……。


### void 函數與回傳值 ###

有時候我必須輸出字串，但回傳字串太麻煩了，
我就在函數中直接輸出。
函數就宣告成 void ，沒有回傳值的函數。
其實沒有回傳值不是好事，
一般回傳值是用來判斷執行的情況的。
像 printf 會回傳輸出的字數。
如果回傳負數代表出錯，對應不同的數值有不同的意義。
void 只應該使用在不需驗證的情況，
也就是 *不會出錯* 或 *無法驗證* 的操作。
像指標的操作。


### map 與 getchar ###

我寫了個副程式，回傳一個 128 字元的陣列，
*記錄* 該字串有什麼字母。
所以用 static 宣告了 `char map[128]` ，好像有點大……。

另外讀到一個有趣的說明， `getchar()` *不應該* 用字元接回傳值；
因為 getchar() 如果出錯會回傳 `EOF` ，
而在 GNU C 中 EOF 是個 Macro ， `# define EOF -1` 。
是的， EOF = -1 。
而 char 是無號整數，所以不能接收 EOF 。
故請使用 int 來接 getchar 。

在 unix 中按下 `^D` ，也就是輸出 ascii 字元 
`EOT` 等同 *關閉 stream* ，和檔案結尾 EOF 有八成像。
但 EOT 不是 EOF ，無論在 ascii 或 unicode 中都沒有 EOF 這個字元。
EOF 並不是一個字元，是一個 **概念** ，等同於 *stream 的結束* 。
在 unix 中使用 EOT ，在 GNU C 中使用整數的 -1 ，
在 windows 中使用 `^Z` 也就是 `SUB` 。


### scanf 與 fgets ###

**不要使用 `gets()` ！** gets 是不安全的。
改使用 `fgets(str, 10, stdin)` ，可以手動指定讀入大小。
使用 scanf 時也應注意，應手動指定讀入大小 
`scanf("%10s", str)` ，防止 overflow 。

另外 scanf 的 `%s` 有點特別，他 **不吃空白符** 。
而他所謂的空白符包括：空白鍵、 tab 、換行符、回車符。
要 %s 吃空白可以手動指定；
例如手動指定字串包括換行以外的所有字元 `%[^\n]s` 。
所以以下是可以的，因為 %s 會自動被 \n 斷開。

	scanf("%s", str[0]);
	scanf("%s", str[1]);



## 程式操作 ##

由於老師給的範例中並沒有提示文字，
本程式運行過程也不會有提示。

 1. 首先執行程式後會停在這裡。（底線為游標。）

	C:\Documents and Settings\NCKU\桌面\HW4_C34031328>HW4_C34031328.exe
	_


 2. 輸入二字串，可以以換行符或空白分隔。

	C:\Documents and Settings\NCKU\桌面\HW4_C34031328>HW4_C34031328.exe
	abcde
	cdefg_


	C:\Documents and Settings\NCKU\桌面\HW4_C34031328>HW4_C34031328.exe
	abcde cdefg_


 3. Eneter 後看到結果。

	C:\Documents and Settings\NCKU\桌面\HW4_C34031328>HW4_C34031328.exe
	abcdef
	cdefg
	abcde
	
	abcdefcdefg
	agfedcfedcba
	0
	cdef
	ab
	abcdef
	CDEFG


 4. 也可以直接把字串當參數傳給程式。
	程式會依據是否收到參數來判別要讀取幾個字串。

	C:\Documents and Settings\NCKU\桌面\HW4_C34031328>HW4_C34031328.exe abcdef cdefg



### bugs ###

我已經儘量作到符合要求了......，
如果按老師開出的條件作測試是不會有錯誤的。
但還是寫一下有什麼 bug 。

單一字串長度超過 20 
:	只會把讀入前 20 個字元。
:	剩下的會留給下一個字串；如果有下一個的話。

只輸入一個字串
:	會等你輸入第二個字串。
:	**字串** 指非換行 、 空白 、 Tab 字元任意個。

輸入多於一個字串
:	只會讀入前兩個字串。

空字串
:	如果要輸入空字串，需把空字串當參數傳入。
:	像 `./HW4_C34031328.exe "" ''` ；其中 `""` 或 `''` 是 bash 的語法，
:	引號內容為字串，但引號內為空，即空字串。
:	空字串不會造成問題。
